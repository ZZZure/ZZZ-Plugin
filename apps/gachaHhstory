import fs from 'node:fs'
import path from 'node:path'
import fetch from 'node-fetch'

// è¿œç¨‹å¡æ± æ•°æ®æº
const DATA_URL = 'https://raw.githubusercontent.com/iaoongin/GachaClock/main/spider/data/zzz/history.json';

// è¿œç¨‹åˆ«åæº (åŒé‡ä¿é™©)
const ALIAS_SOURCES = [
    'https://raw.githubusercontent.com/ZZZure/ZZZ-Plugin/main/defSet/alias.yaml',
    'https://raw.githubusercontent.com/Nwflower/zzz-atlas/master/othername/Role.yaml
    'https://raw.githubusercontent.com/Nwflower/zzz-atlas/master/othername/éŸ³æ“Ž.yaml
];

// æ¸¸æˆé…ç½®
const GAME_CONFIG = {
    prefixes: ['#ç»åŒºé›¶', '%', 'ç»åŒºé›¶'],
    name: 'ç»åŒºé›¶',
    type: 'è°ƒé¢‘'
};

// å†…ç½®ä¿åº•åˆ«å
const BUILTIN_ALIAS = {
    "è‰¾èŽ²": ["é²¨é±¼å¦¹", "é²¨é±¼"],
    "æœ±é¸¢": ["æœ±å…ƒ", "è­¦å‘˜"],
    "ç®€": ["Jane", "è€—å­"],
    "é›…": ["æ˜Ÿè§é›…"]
};

export class CardPoolQuery extends plugin {
    constructor() {
        super({
            name: "å¡æ± æŸ¥è¯¢",
            dsc: "æŸ¥è¯¢ç»åŒºé›¶å…¨è§’è‰²/æ­¦å™¨å¡æ± è®°å½•",
            event: "message",
            priority: -114514,
            rule: [
                { reg: 'å¤åˆ»ç»Ÿè®¡', fnc: 'dispatchHandler' },
                { reg: 'å¡æ± $', fnc: 'dispatchVersionHandler' },
                { reg: '(å½“å‰|æœ¬æœŸ|å½“æœŸ)å¡æ± $', fnc: 'queryCurrentPool' }
            ]
        });
        
        this.aliasMap = null;
    }

    /**
     * èŽ·å–åˆ«åæ˜ å°„è¡¨ (å¤šæºåˆå¹¶)
     */
    async getAliasMap() {
        if (this.aliasMap) return this.aliasMap;

        let finalMap = { ...BUILTIN_ALIAS };
        let loadedSources = 0;

        // === 1. ZZZ-Plugin è·¯å¾„ ===
        const zzzPaths = [
            path.join(process.cwd(), 'plugins', 'ZZZ-Plugin', 'config', 'alias.yaml'),
            path.join(process.cwd(), 'plugins', 'ZZZ-Plugin', 'defSet', 'alias.yaml'),
            path.join(process.cwd(), 'plugins', 'zzz-plugin', 'defSet', 'alias.yaml')
        ];

        for (const filePath of zzzPaths) {
            if (this.mergeLocalYaml(filePath, finalMap)) loadedSources++;
        }

        // === 2. Atlas è·¯å¾„ (ç›®å½•æ‰«ææ¨¡å¼) ===
        // è¿™é‡ŒåŠ å…¥äº†æ‚¨æåˆ°çš„åµŒå¥—ç»“æž„
        const atlasDirs = [
            // æ ‡å‡†è·¯å¾„
            path.join(process.cwd(), 'plugins', 'Atlas', 'othername'),
            path.join(process.cwd(), 'plugins', 'zzz-atlas', 'othername'),
            
            // ã€å…³é”®ä¿®å¤ã€‘é’ˆå¯¹æ‚¨çš„åµŒå¥—è·¯å¾„ plugins/Atlas/zzz-atlas/othername
            path.join(process.cwd(), 'plugins', 'Atlas', 'zzz-atlas', 'othername'),
            path.join(process.cwd(), 'plugins', 'Atlas', 'zzz-atlas', 'config'),
            
            // å…¶ä»–å¯èƒ½
            path.join(process.cwd(), 'plugins', 'Nwflower-zzz-atlas', 'othername')
        ];

        for (const dirPath of atlasDirs) {
            // é€’å½’æ‰«æè¯¥ç›®å½•ä¸‹æ‰€æœ‰yamlæ–‡ä»¶
            if (this.mergeLocalDir(dirPath, finalMap)) loadedSources++;
        }

        // === 3. è¿œç¨‹ä¿åº• ===
        // å¦‚æžœæœ¬åœ°å®Œå…¨æ²¡è¯»åˆ°ï¼Œæˆ–è€…ä¸ºäº†ä¿é™©èµ·è§è¡¥å……æ•°æ®
        // (å³ä½¿è¯»åˆ°äº†æœ¬åœ°ï¼Œä¹Ÿå°è¯•åŽ»è¯»ä¸€ä¸‹è¿œç¨‹çš„éŸ³æ“Žè¡¨ï¼Œé˜²æ­¢æœ¬åœ°æ–‡ä»¶ç¼ºå¤±)
        if (loadedSources === 0 || !this.checkKeyExists(finalMap, 'èˆ¬å²³')) { 
            // logger.mark('[å¡æ± æŸ¥è¯¢] å°è¯•è¡¥å……è¿œç¨‹åˆ«åæ•°æ®...');
            for (const url of ALIAS_SOURCES) {
                await this.mergeRemoteYaml(encodeURI(url), finalMap);
            }
        }

        logger.mark(`[å¡æ± æŸ¥è¯¢] åˆ«ååŠ è½½å®Œæˆï¼Œå…±æ•´åˆ ${Object.keys(finalMap).length} ä¸ªæ¡ç›®`);
        this.aliasMap = finalMap;
        return this.aliasMap;
    }

    checkKeyExists(map, keyword) {
        // ç®€å•æ£€æŸ¥æ˜¯å¦åŒ…å«æŸä¸ªå…³é”®è¯çš„keyï¼Œç”¨äºŽåˆ¤æ–­æ˜¯å¦éœ€è¦è¿œç¨‹è¡¥å…¨
        return Object.keys(map).some(k => k.includes(keyword));
    }

    /**
     * æ‰«æç›®å½•ä¸‹çš„æ‰€æœ‰ YAML æ–‡ä»¶
     */
    mergeLocalDir(dirPath, targetMap) {
        try {
            if (fs.existsSync(dirPath) && fs.statSync(dirPath).isDirectory()) {
                const files = fs.readdirSync(dirPath);
                let mergedCount = 0;
                
                for (const file of files) {
                    if (file.endsWith('.yaml') || file.endsWith('.yml')) {
                        const fullPath = path.join(dirPath, file);
                        if (this.mergeLocalYaml(fullPath, targetMap)) {
                            mergedCount++;
                        }
                    }
                }
                
                if (mergedCount > 0) {
                    // logger.mark(`[å¡æ± æŸ¥è¯¢] æ‰«æç›®å½•æˆåŠŸ: ${dirPath}`);
                    return true;
                }
            }
        } catch (err) { }
        return false;
    }

    /**
     * è¯»å–å¹¶åˆå¹¶å•ä¸ªæœ¬åœ° YAML
     */
    mergeLocalYaml(filePath, targetMap) {
        try {
            if (fs.existsSync(filePath)) {
                const content = fs.readFileSync(filePath, 'utf-8');
                const parsed = this.parseYamlSimple(content);
                this.mergeMaps(targetMap, parsed);
                return true;
            }
        } catch (err) { }
        return false;
    }

    /**
     * è¯»å–å¹¶åˆå¹¶è¿œç¨‹ YAML
     */
    async mergeRemoteYaml(url, targetMap) {
        try {
            const response = await fetch(url, { timeout: 3000 });
            if (response.ok) {
                const text = await response.text();
                const parsed = this.parseYamlSimple(text);
                this.mergeMaps(targetMap, parsed);
            }
        } catch (err) { }
    }

    /**
     * åˆå¹¶ Map
     */
    mergeMaps(target, source) {
        for (const [key, aliases] of Object.entries(source)) {
            if (!target[key]) {
                target[key] = aliases;
            } else {
                const newAliases = new Set([...target[key], ...aliases]);
                target[key] = Array.from(newAliases);
            }
        }
    }

    /**
     * ç®€å•çš„ YAML è§£æžå™¨ (æ”¯æŒç¼©è¿›)
     */
    parseYamlSimple(yamlStr) {
        const result = {};
        const lines = yamlStr.split(/\r?\n/);
        let currentKey = null;

        lines.forEach(line => {
            const rawLine = line.trimEnd(); 
            const trimmedLine = rawLine.trim();
            
            if (!trimmedLine || trimmedLine.startsWith('#')) return;

            // 1. åŒ¹é… Key (å…è®¸å‰å¯¼ç©ºæ ¼ï¼ŒåŽ»é™¤å¼•å·)
            // ç¤ºä¾‹: "èˆ¬å²³ä¸“æ­¦": æˆ– èˆ¬å²³ä¸“æ­¦:
            const keyMatch = rawLine.match(/^\s*['"]?(.+?)['"]?:\s*$/);
            if (keyMatch) {
                currentKey = keyMatch[1];
                if (!result[currentKey]) result[currentKey] = [];
                return;
            }

            // 2. åŒ¹é… Value (å…è®¸ç¼©è¿›)
            const valMatch = rawLine.match(/^\s*-\s+['"]?(.+?)['"]?$/);
            if (currentKey && valMatch) {
                const alias = valMatch[1];
                if (!result[currentKey].includes(alias)) {
                    result[currentKey].push(alias);
                }
            }
        });
        return result;
    }

    // ================= ä¸šåŠ¡é€»è¾‘ =================

    async dispatchHandler(e) {
        const rawContent = this.parsePrefix(e.msg);
        if (!rawContent) return false;

        try {
            if (['äº”æ˜Ÿå¤åˆ»ç»Ÿè®¡', 'å¤åˆ»ç»Ÿè®¡', 'Sçº§å¤åˆ»ç»Ÿè®¡'].includes(rawContent)) {
                return await this.handleSummary(e, 'S', 'è§’è‰²');
            }
            if (['äº”æ˜Ÿæ­¦å™¨å¤åˆ»ç»Ÿè®¡', 'äº”æ˜ŸéŸ³æ“Žå¤åˆ»ç»Ÿè®¡', 'Sçº§éŸ³æ“Žå¤åˆ»ç»Ÿè®¡'].includes(rawContent)) {
                return await this.handleSummary(e, 'S', 'æ­¦å™¨');
            }
            if (['å››æ˜Ÿå¤åˆ»ç»Ÿè®¡', 'å››æ˜Ÿè§’è‰²å¤åˆ»ç»Ÿè®¡', 'Açº§å¤åˆ»ç»Ÿè®¡'].includes(rawContent)) {
                return await this.handleSummary(e, 'A', 'è§’è‰²');
            }
            if (['å››æ˜Ÿæ­¦å™¨å¤åˆ»ç»Ÿè®¡', 'å››æ˜ŸéŸ³æ“Žå¤åˆ»ç»Ÿè®¡', 'Açº§éŸ³æ“Žå¤åˆ»ç»Ÿè®¡'].includes(rawContent)) {
                return await this.handleSummary(e, 'A', 'æ­¦å™¨');
            }

            const match = rawContent.match(/^(.*?)å¤åˆ»ç»Ÿè®¡$/);
            if (match && match[1]) {
                const rawName = match[1].trim();
                const officialName = await this.normalizeName(rawName);
                return await this.handleHistoryQuery(e, officialName);
            }
            return false;
        } catch (err) {
            logger.error(`[å¡æ± æŸ¥è¯¢] è¿è¡ŒæŠ¥é”™: ${err}`);
            return e.reply(`æ’ä»¶è¿è¡Œå‡ºé”™: ${err.message}`);
        }
    }

    async normalizeName(inputName) {
        const map = await this.getAliasMap();
        if (map[inputName]) return inputName;
        const lowerInput = inputName.toLowerCase();
        for (const [realName, aliases] of Object.entries(map)) {
            if (realName.toLowerCase() === lowerInput) return realName;
            if (aliases.some(alias => alias.toLowerCase() === lowerInput)) {
                return realName;
            }
        }
        return inputName;
    }

    // ... ä¸‹é¢æ˜¯å…¶ä»–æŸ¥è¯¢åŠŸèƒ½ (ä¿æŒä¸å˜) ...

    async dispatchVersionHandler(e) {
        const content = this.parsePrefix(e.msg);
        if (!content) return false;
        if (['å½“å‰å¡æ± ', 'æœ¬æœŸå¡æ± ', 'å½“æœŸå¡æ± '].includes(content)) return await this.queryCurrentPool(e);
        const match = content.match(/^v?(\d+\.\d+)(ä¸ŠåŠ|ä¸‹åŠ)?å¡æ± $/);
        if (match) return await this.handleVersionQuery(e, match[1], match[2]);
        return false;
    }

    parsePrefix(msg) {
        msg = msg.trim();
        for (const p of GAME_CONFIG.prefixes) {
            if (msg.startsWith(p)) return msg.substring(p.length).trim();
        }
        return null;
    }

    async queryCurrentPool(e) {
        const data = await this.fetchData();
        if (!data) return e.reply('æ•°æ®æºè¿žæŽ¥å¤±è´¥');
        const now = new Date();
        const activePools = data.filter(pool => {
            const { startTime, endTime } = this.parseTimer(pool.timer);
            return startTime && endTime && now >= startTime && now <= endTime;
        });
        if (activePools.length === 0) return e.reply('å½“å‰æ²¡æœ‰æ­£åœ¨è¿›è¡Œçš„æ´»åŠ¨å¡æ± ã€‚');
        
        let replyMsg = `=== ðŸ“… ç»åŒºé›¶æœ¬æœŸå¡æ±  ===\n`;
        if (activePools.length > 0) {
            const sample = activePools[0];
            const { endTime } = this.parseTimer(sample.timer);
            const remainingDays = Math.ceil((endTime - now) / (1000 * 60 * 60 * 24));
            const timerStr = sample.timer.replace(/ \d{2}:\d{2}:\d{2}/g, '');
            replyMsg += `ç‰ˆæœ¬ï¼šv${sample.version}\næ—¶é—´ï¼š${timerStr}\nçŠ¶æ€ï¼šå‰©ä½™çº¦ ${remainingDays} å¤©\n`;
        }
        replyMsg += `----------------\n`;
        const rolePools = activePools.filter(p => p.type === 'è§’è‰²' || p.type === 'character');
        const weaponPools = activePools.filter(p => p.type === 'æ­¦å™¨' || p.type === 'weapon');
        if (rolePools.length > 0) {
            replyMsg += `ã€è§’è‰²è°ƒé¢‘ã€‘\n`;
            rolePools.forEach(p => {
                const aRoles = Array.isArray(p.a) ? p.a.join(', ') : p.a;
                replyMsg += `â—ˆ S-${p.s}\n   A-${aRoles}\n`;
            });
        }
        if (weaponPools.length > 0) {
            replyMsg += `\nã€éŸ³æ“Žè°ƒé¢‘ã€‘\n`;
            weaponPools.forEach(p => {
                const aWeapons = Array.isArray(p.a) ? p.a.join(', ') : p.a;
                replyMsg += `â—ˆ S-${p.s}\n   A-${aWeapons}\n`;
            });
        }
        return e.reply(replyMsg.trim());
    }

    async handleVersionQuery(e, version, phase) {
        const data = await this.fetchData();
        if (!data) return e.reply('æ•°æ®æºè¿žæŽ¥å¤±è´¥');
        const pools = data.filter(pool => {
            if (!pool.version.includes(version)) return false;
            if (phase && !pool.version.includes(phase)) return false;
            return true;
        });
        if (pools.length === 0) return e.reply(`æœªæŸ¥è¯¢åˆ° ${version}${phase || ''} ç‰ˆæœ¬çš„å¡æ± æ•°æ®ã€‚`);
        const versionStages = [...new Set(pools.map(p => p.version))].sort((a, b) => {
            if (a.includes('ä¸ŠåŠ') && b.includes('ä¸‹åŠ')) return -1;
            if (a.includes('ä¸‹åŠ') && b.includes('ä¸ŠåŠ')) return 1;
            return a.localeCompare(b);
        });
        let replyMsg = `=== ç»åŒºé›¶ v${version} å¡æ± ä¸€è§ˆ ===\n`;
        for (const stage of versionStages) {
            const stagePools = pools.filter(p => p.version === stage);
            let timerDisplay = '';
            if (stagePools.length > 0 && stagePools[0].timer) {
                timerDisplay = stagePools[0].timer.replace(/ \d{2}:\d{2}:\d{2}/g, '');
            }
            const rolePools = stagePools.filter(p => p.type === 'è§’è‰²' || p.type === 'character');
            const weaponPools = stagePools.filter(p => p.type === 'æ­¦å™¨' || p.type === 'weapon');
            replyMsg += `\nã€${stage}ã€‘\nâ±ï¸ ${timerDisplay}\n`;
            if (rolePools.length > 0) {
                const roles = rolePools.map(p => {
                    const aRoles = Array.isArray(p.a) ? p.a.join(', ') : p.a;
                    return `S-${p.s} | A-${aRoles}`;
                }).join('\n   ');
                replyMsg += `â—ˆ è§’è‰²ï¼š${roles}\n`;
            }
            if (weaponPools.length > 0) {
                const weapons = weaponPools.map(p => {
                    const aWeapons = Array.isArray(p.a) ? p.a.join(', ') : p.a;
                    return `S-${p.s} | A-${aWeapons}`;
                }).join('\n   ');
                replyMsg += `â—ˆ éŸ³æ“Žï¼š${weapons}\n`;
            }
        }
        return e.reply(replyMsg.trim());
    }

    async handleSummary(e, targetRank, targetType) {
        const data = await this.fetchData();
        if (!data) return e.reply('æ•°æ®æºè¿žæŽ¥å¤±è´¥');
        const now = new Date();
        const itemMap = new Map();
        data.forEach(pool => {
            if (pool.type !== targetType) return;
            const { startTime, endTime } = this.parseTimer(pool.timer);
            if (!endTime) return;
            let targets = [];
            if (targetRank === 'S') {
                if (pool.s) targets.push(pool.s);
            } else {
                if (Array.isArray(pool.a)) targets = pool.a;
            }
            targets.forEach(name => {
                if (!itemMap.has(name) || endTime > itemMap.get(name).endTime) {
                    itemMap.set(name, { startTime, endTime });
                }
            });
        });
        const currentList = [];
        const historyList = [];
        itemMap.forEach((timeInfo, name) => {
            if (now >= timeInfo.startTime && now <= timeInfo.endTime) {
                currentList.push(name);
            } else {
                if (now < timeInfo.startTime) return;
                const diff = now - timeInfo.endTime;
                const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                historyList.push({ name, days: days > 0 ? days : 0 });
            }
        });
        historyList.sort((a, b) => b.days - a.days);
        const currentStr = currentList.length > 0 ? currentList.join(', ') : 'æš‚æ— ';
        const historyStr = historyList.map(r => `${r.name}: å·² ${String(r.days).padStart(3, ' ')} å¤©æœªå¤åˆ»`).join('\n');
        const displayType = targetType === 'æ­¦å™¨' ? 'éŸ³æ“Ž' : 'è§’è‰²';
        return e.reply(`å½“å‰${displayType}è°ƒé¢‘: ${currentStr}\n--- ${targetRank}çº§${displayType}å¤åˆ»ç»Ÿè®¡ ---\n${historyStr}`);
    }

    async handleHistoryQuery(e, queryName) {
        const data = await this.fetchData();
        const records = data.filter(pool => {
            if (pool.s === queryName) return true;
            if (Array.isArray(pool.a) && pool.a.includes(queryName)) return true;
            return false;
        });
        if (records.length === 0) {
            const sourceUrl = encodeURI(DATA_URL);
            return e.reply(`æœªæ‰¾åˆ° [${queryName}] çš„è®°å½•ã€‚\nè¯·ç¡®è®¤åˆ«åå­˜åœ¨æˆ–è¿œç¨‹ä»“åº“æ˜¯å¦å·²æ›´æ–°: ${sourceUrl}`);
        }
        const firstHit = records[0];
        const isS = firstHit.s === queryName;
        const typeStr = firstHit.type === 'æ­¦å™¨' ? 'éŸ³æ“Ž' : 'è§’è‰²';
        const rarityStr = isS ? 'Sçº§' : 'Açº§';
        const listStr = records.map((pool, index) => {
            const timeRange = pool.timer.replace(/ \d{2}:\d{2}:\d{2}/g, ''); 
            return `${index + 1}. ${pool.version} (${timeRange})`;
        }).join('\n');
        return e.reply(`--- ${queryName} (${rarityStr}${typeStr}) ---\n${listStr}`);
    }

    parseTimer(timerStr) {
        if (!timerStr) return { startTime: null, endTime: null };
        const parts = timerStr.split('~');
        if (parts.length < 2) return { startTime: null, endTime: null };
        let startStr = parts[0].trim();
        let endStr = parts[1].trim();
        let startTime = new Date(startStr);
        let endTime = new Date(endStr);
        if (isNaN(startTime.getTime())) startTime = null;
        return { startTime, endTime };
    }

    async fetchData() {
        const response = await fetch(DATA_URL, { method: 'GET', headers: { 'Cache-Control': 'no-cache' }, timeout: 10000 });
        if (!response.ok) return null;
        let data = await response.json();
        return this.preprocessData(data);
    }

    preprocessData(data) {
        data.forEach(pool => {
            const parts = pool.timer.split('~');
            if (parts.length >= 2) {
                const endStr = parts[1].trim();
                const endTime = new Date(endStr);
                pool._endTimeStamp = isNaN(endTime.getTime()) ? 0 : endTime.getTime();
            } else {
                pool._endTimeStamp = 0;
            }
        });
        data.sort((a, b) => a._endTimeStamp - b._endTimeStamp);
        for (let i = 0; i < data.length; i++) {
            const pool = data[i];
            if (pool.timer.includes('ç‰ˆæœ¬æ›´æ–°åŽ')) {
                const parts = pool.timer.split('~');
                const endPart = parts[1];
                let prevEndTime = 0;
                for (let j = i - 1; j >= 0; j--) {
                    const prev = data[j];
                    if (prev._endTimeStamp > 0 && prev._endTimeStamp < pool._endTimeStamp) {
                        prevEndTime = prev._endTimeStamp;
                        break; 
                    }
                }
                if (prevEndTime > 0) {
                    const d = new Date(prevEndTime);
                    d.setDate(d.getDate() + 1); 
                    const year = d.getFullYear();
                    const month = String(d.getMonth() + 1).padStart(2, '0');
                    const day = String(d.getDate()).padStart(2, '0');
                    pool.timer = `${year}/${month}/${day} 11:00:00 ~ ${endPart}`;
                } else {
                    pool.timer = `2024/07/04 10:00:00 ~ ${endPart}`;
                }
            }
        }
        return data;
    }
}
